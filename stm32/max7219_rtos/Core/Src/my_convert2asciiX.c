//http://arv.radioliga.com/content/view/106/49/

#include "my_convert2asciiX.h"

// массив символов, соответствующих ЦИФРАМ выбранной системы счисления
volatile unsigned char SYMBOLS[DIG_BASE] = {'0','1','2','3','4','5','6','7','8','9'};

//funcs

void ConvertX(char* outx,u32 NUM,u08 X) {
	for(u08 k=0;k<MAX_SIZE;k++){
			outx[k]=0;
	}

	 int i, m;	 
	 if ((X==0)||(X>MAX_SIZE)){
	 	outx[0]='E';outx[1]='R';outx[2]='R';outx[3]='O';outx[4]='R';
		return;
	 }
	for(i=X-1; i>=0; i--) {		// цикл заполнения выходного массива СПРАВА НАЛЕВО
	    m = NUM % DIG_BASE; 			// находим остаток от деления числа на основание
	    outx[i] = SYMBOLS[m]; 			// этот остаток есть ВЫВОДИМАЯ ЦИФРА
		NUM /= DIG_BASE;  				// уменьшаем число в DIG_BASE раз
	}
}
//---------------------------------------------------
//вывод без незначащих нулей впереди
void TrimConvertX(char *outx,u32 NUM,u08 X) {
	for(u08 k=0;k<MAX_SIZE;k++){
			outx[k]=0;
	}

	 int i, m;
	 if ((X==0)||(X>9)){
	 	outx[0]='E';outx[1]='R';outx[2]='R';outx[3]='O';outx[4]='R';
		return;
	 }		
	 for(i=X-1; i>=0; i--) {		 // цикл заполнения выходного массива СПРАВА НАЛЕВО
	  	m = NUM % DIG_BASE; // находим остаток от деления числа на основание
	    if((NUM==0)&&(i!=(X-1))) // если наше число - ноль и вывод НЕ в правую позицию
			outx[i] = SPACE_CHAR; 		// то выводим "пустое" место - подавляем незначащие нули
		else  outx[i] = SYMBOLS[m]; 		// иначе выводим символ нужной ЦИФРЫ
		    NUM /= DIG_BASE;  			// уменьшаем число в DIG_BASE раз
	 }
}
//---------------------------------------------------
//ф-я для вывода отрицательных чисел
void STrimConvertX(char *outx,s32 NUM,u08 X) {
	for(u08 k=0;k<MAX_SIZE;k++){
			outx[k]=0;
	}

int i, m, sign = 0;
	 if(NUM <0) { 						// если число отрицательное
		sign = 1; 						// установим признак наличия знака
		NUM *= -1; 						// а само число возьмем по модулю
	 }	
	  									// выводим уже положительное число
	 i=X-1;
	 do
	 { 									 // цикл заполнения выходного массива СПРАВА НАЛЕВО
		m = NUM % DIG_BASE; 			 // находим остаток от деления числа на основание
		if((NUM==0)&&(i!=(X-1)))
		   break; 						// закончим цикл вывода числа
		else outx[i] = SYMBOLS[m];		 // иначе выводим символ нужной ЦИФРЫ
		NUM /= DIG_BASE;  				// уменьшаем число в DIG_BASE раз
	 }
	 while (--i >= 0); 					// число выведено, проверяем свободное место и выводим при необходимости знак
		if (i<0) return; 				// места не хватает - выход
		if (sign) outx[i--] = NEG_CHAR; // выводим знак, если нужно
		for(;i>=0;i--) outx[i] = SPACE_CHAR; // очищаем незначащие позиции
}

/*
//-----------------------------
#define COMMA_CHAR '.' // это символ десятичной точки
			// десятичная точка не занимает отдельного места на семисегментном индикаторе !
float tmp1 = 2.15; // пусть это число, которое надо вывести
//convert((unsigned int)(tmp1*100)); // выведем увеличенное в 100 раз число tmp, преобразованное к целому
//out[MAX_SIZE-2] |= COMMA_CHAR; // добавим точку к нужному разряду индикатора
			

*/			



