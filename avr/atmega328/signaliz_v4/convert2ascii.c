//http://arv.radioliga.com/content/view/106/49/

#include "convert2ascii.h"

// массив символов, соответствующих ЦИФРАМ выбранной системы счисления
unsigned char SYMBOLS[DIG_BASE] = {'0','1','2','3','4','5','6','7','8','9'};
//unsigned char out_sign[MAX_SIZE_SIGN]; // выходной массив символов (экранная область)
unsigned char out[MAX_SIZE]; // выходной массив символов (экранная область)

//funcs

void Convert(uint32_t NUM,uint8_t X){
	int i, m;
	 if ((X==0)||(X>9)){
	 	out[0]='E';out[1]='R';out[2]='R';out[3]='O';out[4]='R';
		return;
	 }
	for(i=X-1; i>=0; i--) {		// цикл заполнения выходного массива СПРАВА НАЛЕВО
	    m = NUM % DIG_BASE; 			// находим остаток от деления числа на основание
	    out[i] = SYMBOLS[m]; 			// этот остаток есть ВЫВОДИМАЯ ЦИФРА
		NUM /= DIG_BASE;  				// уменьшаем число в DIG_BASE раз
	}
}

//вывод без незначащих нулей впереди
void TrimConvert(uint32_t NUM,uint8_t X) {
	 int i, m;
	 if ((X==0)||(X>9)){
	 	out[0]='E';out[1]='R';out[2]='R';out[3]='O';out[4]='R';
		return;
	 }		
	 for(i=X-1; i>=0; i--) {		 // цикл заполнения выходного массива СПРАВА НАЛЕВО
	  	m = NUM % DIG_BASE; // находим остаток от деления числа на основание
	    if((NUM==0)&&(i!=(X-1))) // если наше число - ноль и вывод НЕ в правую позицию
			out[i] = SPACE_CHAR; 		// то выводим "пустое" место - подавляем незначащие нули
		else  out[i] = SYMBOLS[m]; 		// иначе выводим символ нужной ЦИФРЫ
		    NUM /= DIG_BASE;  			// уменьшаем число в DIG_BASE раз
	 }
}

//ф-я для вывода отрицательных чисел
void STrimConvert(int32_t NUM,uint8_t X) {
int i, m, sign = 0;
	 if(NUM <0) { 						// если число отрицательное
		sign = 1; 						// установим признак наличия знака
		NUM *= -1; 						// а само число возьмем по модулю
	 }	
	  									// выводим уже положительное число
	 i=X-1;
	 do
	 { 									 // цикл заполнения выходного массива СПРАВА НАЛЕВО
		m = NUM % DIG_BASE; 			 // находим остаток от деления числа на основание
		if((NUM==0)&&(i!=(X-1)))
		   break; 						// закончим цикл вывода числа
		else out[i] = SYMBOLS[m];		 // иначе выводим символ нужной ЦИФРЫ
		NUM /= DIG_BASE;  				// уменьшаем число в DIG_BASE раз
	 }
	 while (--i >= 0); 					// число выведено, проверяем свободное место и выводим при необходимости знак
		if (i<0) return; 				// места не хватает - выход
		if (sign) out[i--] = NEG_CHAR; // выводим знак, если нужно
		for(;i>=0;i--) out[i] = SPACE_CHAR; // очищаем незначащие позиции 
}

/*
//-----------------------------
#define COMMA_CHAR '.' // это символ десятичной точки 
			// десятичная точка не занимает отдельного места на семисегментном индикаторе !
float tmp1 = 2.15; // пусть это число, которое надо вывести
//convert((unsigned int)(tmp1*100)); // выведем увеличенное в 100 раз число tmp, преобразованное к целому
//out[MAX_SIZE-2] |= COMMA_CHAR; // добавим точку к нужному разряду индикатора
			

*/			



